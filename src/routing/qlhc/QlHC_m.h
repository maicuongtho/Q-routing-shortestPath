//
// Generated file, do not edit! Created by opp_msgtool 6.0 from routing/qlhc/QlHC.msg.
//

#ifndef __INET_QLHC_M_H
#define __INET_QLHC_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace inet {

class QlHCBeacon;
class QlHCACK;
class QlHCOption;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TlvOptions_m.h" // import inet.common.TlvOptions

#include "inet/common/geometry/Geometry_m.h" // import inet.common.geometry.Geometry

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {

/**
 * Enum generated from <tt>routing/qlhc/QlHC.msg:15</tt> by opp_msgtool.
 * <pre>
 * enum GpsrForwardingMode
 * {
 *     GPSR_GREEDY_ROUTING = 1;
 *     GPSR_PERIMETER_ROUTING = 2;
 * }
 * </pre>
 */
enum GpsrForwardingMode {
    GPSR_GREEDY_ROUTING = 1,
    GPSR_PERIMETER_ROUTING = 2
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GpsrForwardingMode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GpsrForwardingMode& e) { int n; b->unpack(n); e = static_cast<GpsrForwardingMode>(n); }

/**
 * Enum generated from <tt>routing/qlhc/QlHC.msg:20</tt> by opp_msgtool.
 * <pre>
 * enum GpsrPlanarizationMode
 * {
 *     GPSR_NO_PLANARIZATION = 0;
 *     GPSR_GG_PLANARIZATION = 1;
 *     GPSR_RNG_PLANARIZATION = 2;
 * }
 * </pre>
 */
enum GpsrPlanarizationMode {
    GPSR_NO_PLANARIZATION = 0,
    GPSR_GG_PLANARIZATION = 1,
    GPSR_RNG_PLANARIZATION = 2
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GpsrPlanarizationMode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GpsrPlanarizationMode& e) { int n; b->unpack(n); e = static_cast<GpsrPlanarizationMode>(n); }

/**
 * Class generated from <tt>routing/qlhc/QlHC.msg:31</tt> by opp_msgtool.
 * <pre>
 * //
 * // The GPSR beacon packet is sent periodically by all GPSR routers to notify
 * // the neighbors about the router's address and position.
 * //
 * class QlHCBeacon extends FieldsChunk
 * {
 *     L3Address address;
 *     Coord position;
 * }
 * </pre>
 */
class QlHCBeacon : public ::inet::FieldsChunk
{
  protected:
    L3Address address;
    Coord position;

  private:
    void copy(const QlHCBeacon& other);

  protected:
    bool operator==(const QlHCBeacon&) = delete;

  public:
    QlHCBeacon();
    QlHCBeacon(const QlHCBeacon& other);
    virtual ~QlHCBeacon();
    QlHCBeacon& operator=(const QlHCBeacon& other);
    virtual QlHCBeacon *dup() const override {return new QlHCBeacon(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<QlHCBeacon*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);

    virtual const Coord& getPosition() const;
    virtual Coord& getPositionForUpdate() { handleChange();return const_cast<Coord&>(const_cast<QlHCBeacon*>(this)->getPosition());}
    virtual void setPosition(const Coord& position);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const QlHCBeacon& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, QlHCBeacon& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>routing/qlhc/QlHC.msg:37</tt> by opp_msgtool.
 * <pre>
 * class QlHCACK extends FieldsChunk
 * {
 *     L3Address address;
 *     double rewardValue;
 *     double minQvalue2Destination;
 *     L3Address desinationAddressUDPdata;
 * }
 * </pre>
 */
class QlHCACK : public ::inet::FieldsChunk
{
  protected:
    L3Address address;
    double rewardValue = 0;
    double minQvalue2Destination = 0;
    L3Address desinationAddressUDPdata;

  private:
    void copy(const QlHCACK& other);

  protected:
    bool operator==(const QlHCACK&) = delete;

  public:
    QlHCACK();
    QlHCACK(const QlHCACK& other);
    virtual ~QlHCACK();
    QlHCACK& operator=(const QlHCACK& other);
    virtual QlHCACK *dup() const override {return new QlHCACK(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<QlHCACK*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);

    virtual double getRewardValue() const;
    virtual void setRewardValue(double rewardValue);

    virtual double getMinQvalue2Destination() const;
    virtual void setMinQvalue2Destination(double minQvalue2Destination);

    virtual const L3Address& getDesinationAddressUDPdata() const;
    virtual L3Address& getDesinationAddressUDPdataForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<QlHCACK*>(this)->getDesinationAddressUDPdata());}
    virtual void setDesinationAddressUDPdata(const L3Address& desinationAddressUDPdata);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const QlHCACK& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, QlHCACK& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>routing/qlhc/QlHC.msg:49</tt> by opp_msgtool.
 * <pre>
 * //
 * // The GPSROption is used to add extra routing information for network datagrams.
 * //
 * // For more information, see the GPSR paper
 * // http://www.eecs.harvard.edu/~htk/publication/2000-mobi-karp-kung.pdf
 * //
 * class QlHCOption extends TlvOptionBase
 * {
 *     GpsrForwardingMode routingMode;
 *     Coord destinationPosition;               // D
 *     Coord perimeterRoutingStartPosition;     // Lp
 *     Coord perimeterRoutingForwardPosition;   // Lf
 *     L3Address currentFaceFirstSenderAddress;   // e0
 *     L3Address currentFaceFirstReceiverAddress; // e0
 *     L3Address senderAddress; // TODO this field is not strictly needed by GPSR (should be eliminated)
 * }
 * </pre>
 */
class QlHCOption : public ::inet::TlvOptionBase
{
  protected:
    GpsrForwardingMode routingMode = static_cast<inet::GpsrForwardingMode>(-1);
    Coord destinationPosition;
    Coord perimeterRoutingStartPosition;
    Coord perimeterRoutingForwardPosition;
    L3Address currentFaceFirstSenderAddress;
    L3Address currentFaceFirstReceiverAddress;
    L3Address senderAddress;

  private:
    void copy(const QlHCOption& other);

  protected:
    bool operator==(const QlHCOption&) = delete;

  public:
    QlHCOption();
    QlHCOption(const QlHCOption& other);
    virtual ~QlHCOption();
    QlHCOption& operator=(const QlHCOption& other);
    virtual QlHCOption *dup() const override {return new QlHCOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual GpsrForwardingMode getRoutingMode() const;
    virtual void setRoutingMode(GpsrForwardingMode routingMode);

    virtual const Coord& getDestinationPosition() const;
    virtual Coord& getDestinationPositionForUpdate() { return const_cast<Coord&>(const_cast<QlHCOption*>(this)->getDestinationPosition());}
    virtual void setDestinationPosition(const Coord& destinationPosition);

    virtual const Coord& getPerimeterRoutingStartPosition() const;
    virtual Coord& getPerimeterRoutingStartPositionForUpdate() { return const_cast<Coord&>(const_cast<QlHCOption*>(this)->getPerimeterRoutingStartPosition());}
    virtual void setPerimeterRoutingStartPosition(const Coord& perimeterRoutingStartPosition);

    virtual const Coord& getPerimeterRoutingForwardPosition() const;
    virtual Coord& getPerimeterRoutingForwardPositionForUpdate() { return const_cast<Coord&>(const_cast<QlHCOption*>(this)->getPerimeterRoutingForwardPosition());}
    virtual void setPerimeterRoutingForwardPosition(const Coord& perimeterRoutingForwardPosition);

    virtual const L3Address& getCurrentFaceFirstSenderAddress() const;
    virtual L3Address& getCurrentFaceFirstSenderAddressForUpdate() { return const_cast<L3Address&>(const_cast<QlHCOption*>(this)->getCurrentFaceFirstSenderAddress());}
    virtual void setCurrentFaceFirstSenderAddress(const L3Address& currentFaceFirstSenderAddress);

    virtual const L3Address& getCurrentFaceFirstReceiverAddress() const;
    virtual L3Address& getCurrentFaceFirstReceiverAddressForUpdate() { return const_cast<L3Address&>(const_cast<QlHCOption*>(this)->getCurrentFaceFirstReceiverAddress());}
    virtual void setCurrentFaceFirstReceiverAddress(const L3Address& currentFaceFirstReceiverAddress);

    virtual const L3Address& getSenderAddress() const;
    virtual L3Address& getSenderAddressForUpdate() { return const_cast<L3Address&>(const_cast<QlHCOption*>(this)->getSenderAddress());}
    virtual void setSenderAddress(const L3Address& senderAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const QlHCOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, QlHCOption& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

template<> inline inet::QlHCBeacon *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::QlHCBeacon*>(ptr.get<cObject>()); }
template<> inline inet::QlHCACK *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::QlHCACK*>(ptr.get<cObject>()); }
template<> inline inet::QlHCOption *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::QlHCOption*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_QLHC_M_H

